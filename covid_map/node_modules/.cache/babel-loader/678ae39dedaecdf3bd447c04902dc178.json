{"ast":null,"code":"'use strict';\n\nconst {\n  URL\n} = require('url');\n\nconst urlRegex = require('url-regex');\n\nconst normalizeUrl = require('normalize-url');\n\nconst getUrlsFromQueryParams = url => {\n  const ret = new Set();\n  const {\n    searchParams\n  } = new URL(url.replace(/^(\\/\\/|(www\\.))/, 'http://$2'));\n\n  for (const [, value] of searchParams) {\n    if (urlRegex({\n      exact: true\n    }).test(value)) {\n      ret.add(value);\n    }\n  }\n\n  return ret;\n};\n\nmodule.exports = (text, options = {}) => {\n  if (typeof options.exclude !== 'undefined' && !Array.isArray(options.exclude)) {\n    throw new TypeError('The `exclude` option must be an array');\n  }\n\n  const ret = new Set();\n\n  const add = url => {\n    try {\n      ret.add(normalizeUrl(url.trim().replace(/\\.+$/, ''), options));\n    } catch (_) {}\n  };\n\n  const urls = text.match(urlRegex(options.requireSchemeOrWww === undefined ? undefined : {\n    strict: options.requireSchemeOrWww\n  })) || [];\n\n  for (const url of urls) {\n    add(url);\n\n    if (options.extractFromQueryString) {\n      const qsUrls = getUrlsFromQueryParams(url);\n\n      for (const qsUrl of qsUrls) {\n        add(qsUrl);\n      }\n    }\n  }\n\n  for (const excludedItem of options.exclude || []) {\n    for (const item of ret) {\n      const regex = new RegExp(excludedItem);\n\n      if (regex.test(item)) {\n        ret.delete(item);\n        break;\n      }\n    }\n  }\n\n  return ret;\n};","map":{"version":3,"sources":["/Users/a3506/Documents/WebDev/Map/WebDev/covid_map/node_modules/get-urls/index.js"],"names":["URL","require","urlRegex","normalizeUrl","getUrlsFromQueryParams","url","ret","Set","searchParams","replace","value","exact","test","add","module","exports","text","options","exclude","Array","isArray","TypeError","trim","_","urls","match","requireSchemeOrWww","undefined","strict","extractFromQueryString","qsUrls","qsUrl","excludedItem","item","regex","RegExp","delete"],"mappings":"AAAA;;AACA,MAAM;AAACA,EAAAA;AAAD,IAAQC,OAAO,CAAC,KAAD,CAArB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,WAAD,CAAxB;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,eAAD,CAA5B;;AAEA,MAAMG,sBAAsB,GAAGC,GAAG,IAAI;AACrC,QAAMC,GAAG,GAAG,IAAIC,GAAJ,EAAZ;AACA,QAAM;AAACC,IAAAA;AAAD,MAAkB,IAAIR,GAAJ,CAAQK,GAAG,CAACI,OAAJ,CAAY,iBAAZ,EAA+B,WAA/B,CAAR,CAAxB;;AAEA,OAAK,MAAM,GAAGC,KAAH,CAAX,IAAwBF,YAAxB,EAAsC;AACrC,QAAIN,QAAQ,CAAC;AAACS,MAAAA,KAAK,EAAE;AAAR,KAAD,CAAR,CAAwBC,IAAxB,CAA6BF,KAA7B,CAAJ,EAAyC;AACxCJ,MAAAA,GAAG,CAACO,GAAJ,CAAQH,KAAR;AACA;AACD;;AAED,SAAOJ,GAAP;AACA,CAXD;;AAaAQ,MAAM,CAACC,OAAP,GAAiB,CAACC,IAAD,EAAOC,OAAO,GAAG,EAAjB,KAAwB;AACxC,MAAI,OAAOA,OAAO,CAACC,OAAf,KAA2B,WAA3B,IAA0C,CAACC,KAAK,CAACC,OAAN,CAAcH,OAAO,CAACC,OAAtB,CAA/C,EAA+E;AAC9E,UAAM,IAAIG,SAAJ,CAAc,uCAAd,CAAN;AACA;;AAED,QAAMf,GAAG,GAAG,IAAIC,GAAJ,EAAZ;;AAEA,QAAMM,GAAG,GAAGR,GAAG,IAAI;AAClB,QAAI;AACHC,MAAAA,GAAG,CAACO,GAAJ,CAAQV,YAAY,CAACE,GAAG,CAACiB,IAAJ,GAAWb,OAAX,CAAmB,MAAnB,EAA2B,EAA3B,CAAD,EAAiCQ,OAAjC,CAApB;AACA,KAFD,CAEE,OAAOM,CAAP,EAAU,CAAE;AACd,GAJD;;AAMA,QAAMC,IAAI,GAAGR,IAAI,CAACS,KAAL,CACZvB,QAAQ,CAACe,OAAO,CAACS,kBAAR,KAA+BC,SAA/B,GAA2CA,SAA3C,GAAuD;AAC/DC,IAAAA,MAAM,EAAEX,OAAO,CAACS;AAD+C,GAAxD,CADI,KAIR,EAJL;;AAKA,OAAK,MAAMrB,GAAX,IAAkBmB,IAAlB,EAAwB;AACvBX,IAAAA,GAAG,CAACR,GAAD,CAAH;;AAEA,QAAIY,OAAO,CAACY,sBAAZ,EAAoC;AACnC,YAAMC,MAAM,GAAG1B,sBAAsB,CAACC,GAAD,CAArC;;AACA,WAAK,MAAM0B,KAAX,IAAoBD,MAApB,EAA4B;AAC3BjB,QAAAA,GAAG,CAACkB,KAAD,CAAH;AACA;AACD;AACD;;AAED,OAAK,MAAMC,YAAX,IAA2Bf,OAAO,CAACC,OAAR,IAAmB,EAA9C,EAAkD;AACjD,SAAK,MAAMe,IAAX,IAAmB3B,GAAnB,EAAwB;AACvB,YAAM4B,KAAK,GAAG,IAAIC,MAAJ,CAAWH,YAAX,CAAd;;AACA,UAAIE,KAAK,CAACtB,IAAN,CAAWqB,IAAX,CAAJ,EAAsB;AACrB3B,QAAAA,GAAG,CAAC8B,MAAJ,CAAWH,IAAX;AACA;AACA;AACD;AACD;;AAED,SAAO3B,GAAP;AACA,CAxCD","sourcesContent":["'use strict';\nconst {URL} = require('url');\nconst urlRegex = require('url-regex');\nconst normalizeUrl = require('normalize-url');\n\nconst getUrlsFromQueryParams = url => {\n\tconst ret = new Set();\n\tconst {searchParams} = (new URL(url.replace(/^(\\/\\/|(www\\.))/, 'http://$2')));\n\n\tfor (const [, value] of searchParams) {\n\t\tif (urlRegex({exact: true}).test(value)) {\n\t\t\tret.add(value);\n\t\t}\n\t}\n\n\treturn ret;\n};\n\nmodule.exports = (text, options = {}) => {\n\tif (typeof options.exclude !== 'undefined' && !Array.isArray(options.exclude)) {\n\t\tthrow new TypeError('The `exclude` option must be an array');\n\t}\n\n\tconst ret = new Set();\n\n\tconst add = url => {\n\t\ttry {\n\t\t\tret.add(normalizeUrl(url.trim().replace(/\\.+$/, ''), options));\n\t\t} catch (_) {}\n\t};\n\n\tconst urls = text.match(\n\t\turlRegex(options.requireSchemeOrWww === undefined ? undefined : {\n\t\t\tstrict: options.requireSchemeOrWww\n\t\t})\n\t) || [];\n\tfor (const url of urls) {\n\t\tadd(url);\n\n\t\tif (options.extractFromQueryString) {\n\t\t\tconst qsUrls = getUrlsFromQueryParams(url);\n\t\t\tfor (const qsUrl of qsUrls) {\n\t\t\t\tadd(qsUrl);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (const excludedItem of options.exclude || []) {\n\t\tfor (const item of ret) {\n\t\t\tconst regex = new RegExp(excludedItem);\n\t\t\tif (regex.test(item)) {\n\t\t\t\tret.delete(item);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n};\n"]},"metadata":{},"sourceType":"script"}