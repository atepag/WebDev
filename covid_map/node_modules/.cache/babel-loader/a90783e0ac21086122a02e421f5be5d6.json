{"ast":null,"code":"import React, { useCallback, useMemo, useState, useRef } from 'react';\nimport { cache } from './config';\n/*\nThe idea\n\nA \"Page\" component renders the content of 1 API request, it accepts an offset (in this example it's from),\nuses a SWR hook (useSWR(API + '?limit=' + limit + '&from=' + from)) and returns items (Projects).\n\nThe UI:\n      +------------------------------------------+\n      |   Projects                               |\n+------------------------------------------------------+\n|     |   +----------------+                     |     |\n|     |                                          |     |\n|     |   +------------+                         |     |\n|     |                                          |     +--> 1 Page\n|     |   +-----------------+                    |     |\n|     |                                          |     |  /projects/list?limit=4\n|     |   +---------+                            |     |\n+------------------------------------------------------+\n      |                                          |\n      |   +------------+                         |     +  /projects/list?limit=4&from=123\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |   +---------+                            |     |\n      |                                          |     |\n      |   +--------------+                       |     +\n      |                                          |\n      |   +-------------------+                  |     +  /projects/list?limit=4&from=456\n      |                                          |     |\n      |   +------------+                         |     |\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |                                          |     +\n\nThe API\n// (inside `render`)\n\nfunction App () {\n  const {\n    pages,    // an array of each page component\n    pageSWRs, // an array of SWRs of each page\n    isLoadingMore,\n    isReachingEnd,\n    isEmpty,\n    loadMore\n  } = useSWRPages(\n    'project-page', // key of this page\n\n    // ======== the actual Page component!\n    ({ offset, withSWR }) => {\n      // required: use `withSWR` to wrap your main SWR (source of your pagination API)\n      const { data } = withSWR(\n        useSWR(API + '?limit=10&from=' + offset) // request projects with offset\n      )\n      if (!data) return <Placeholder>\n      return data.projects.map(project => <Card project={project} team={team}>)\n    },\n    // ========\n\n    // a function accepts a SWR's `data`, and returns the offset of the next page (or null)\n    data => data && data.length >= 10 ? data[data.length - 1].createdAt : null,\n\n    // (optional) outside deps of your Page component. in this case it's empty\n    []\n  )\n\n  // ...\n\n  if (isEmpty) return <EmptyProjectsPage/>\n\n  return <div>\n    {pages}\n    {isReachingEnd\n      ? null\n      : <button loading={isLoadingMore} onClick={loadMore}>Load More</button>}\n  </div>\n}\n*/\n\nconst pageCacheMap = new Map();\nexport function useSWRPages(pageKey, pageFn, SWRToOffset, deps = []) {\n  const pageCountKey = `_swr_page_count_` + pageKey;\n  const pageOffsetKey = `_swr_page_offset_` + pageKey;\n  const [pageCount, setPageCount] = useState(cache.get(pageCountKey) || 1);\n  const [pageOffsets, setPageOffsets] = useState(cache.get(pageOffsetKey) || [null]);\n  const [pageSWRs, setPageSWRs] = useState([]);\n  const pageFnRef = useRef(pageFn);\n  const emptyPageRef = useRef(false); // Page component (wraps `pageFn`)\n  // for performance reason we need to memorize it\n\n  const Page = useCallback(props => {\n    // render the page component\n    const dataList = pageFnRef.current(props); // if dataList is [], we can assume this page is empty\n    // TODO: this API is not stable\n\n    if (dataList && !dataList.length) {\n      emptyPageRef.current = true;\n    } else {\n      emptyPageRef.current = false;\n    }\n\n    return dataList;\n  }, []); // Doesn't have a next page\n\n  const isReachingEnd = pageOffsets[pageCount] === null;\n  const isLoadingMore = pageCount === pageOffsets.length;\n  const isEmpty = isReachingEnd && pageCount === 1 && emptyPageRef.current;\n  const loadMore = useCallback(() => {\n    if (isLoadingMore || isReachingEnd) return;\n    setPageCount(c => {\n      cache.set(pageCountKey, c + 1);\n      return c + 1;\n    });\n  }, [isLoadingMore || isReachingEnd]);\n\n  const _pageFn = useCallback(pageFn, deps);\n\n  pageFnRef.current = _pageFn;\n  const pages = useMemo(() => {\n    const getWithSWR = id => swr => {\n      if (!pageSWRs[id] || pageSWRs[id].data !== swr.data || pageSWRs[id].error !== swr.error || pageSWRs[id].revalidate !== swr.revalidate) {\n        // hoist side effects: setPageSWRs and setPageOffsets -- https://reactjs.org/blog/2020/02/26/react-v16.13.0.html#warnings-for-some-updates-during-render\n        setTimeout(() => {\n          setPageSWRs(swrs => {\n            const _swrs = [...swrs];\n            _swrs[id] = {\n              data: swr.data,\n              error: swr.error,\n              revalidate: swr.revalidate,\n              isValidating: swr.isValidating,\n              mutate: swr.mutate\n            };\n            return _swrs;\n          });\n\n          if (typeof swr.data !== 'undefined') {\n            // set next page's offset\n            const newPageOffset = SWRToOffset(swr, id);\n\n            if (pageOffsets[id + 1] !== newPageOffset) {\n              setPageOffsets(arr => {\n                const _arr = [...arr];\n                _arr[id + 1] = newPageOffset;\n                cache.set(pageOffsetKey, _arr);\n                return _arr;\n              });\n            }\n          }\n        });\n      }\n\n      return swr;\n    }; // render each page\n\n\n    const p = [];\n\n    if (!pageCacheMap.has(pageKey)) {\n      pageCacheMap.set(pageKey, []);\n    }\n\n    const pageCache = pageCacheMap.get(pageKey);\n\n    for (let i = 0; i < pageCount; ++i) {\n      if (!pageCache[i] || pageCache[i].offset !== pageOffsets[i] || pageCache[i].pageFn !== _pageFn) {\n        // when props change or at init\n        // render the page and cache it\n        pageCache[i] = {\n          component: React.createElement(Page, {\n            key: `page-${pageOffsets[i]}-${i}`,\n            offset: pageOffsets[i],\n            withSWR: getWithSWR(i)\n          }),\n          pageFn: _pageFn,\n          offset: pageOffsets[i]\n        };\n      }\n\n      p.push(pageCache[i].component);\n    }\n\n    return p;\n  }, [_pageFn, pageCount, pageSWRs, pageOffsets, pageKey]);\n  return {\n    pages,\n    pageCount,\n    pageSWRs,\n    isLoadingMore,\n    isReachingEnd,\n    isEmpty,\n    loadMore\n  };\n}","map":{"version":3,"sources":["/Users/a3506/Documents/WebDev/Map/WebDev/covid_map/node_modules/swr/esm/use-swr-pages.js"],"names":["React","useCallback","useMemo","useState","useRef","cache","pageCacheMap","Map","useSWRPages","pageKey","pageFn","SWRToOffset","deps","pageCountKey","pageOffsetKey","pageCount","setPageCount","get","pageOffsets","setPageOffsets","pageSWRs","setPageSWRs","pageFnRef","emptyPageRef","Page","props","dataList","current","length","isReachingEnd","isLoadingMore","isEmpty","loadMore","c","set","_pageFn","pages","getWithSWR","id","swr","data","error","revalidate","setTimeout","swrs","_swrs","isValidating","mutate","newPageOffset","arr","_arr","p","has","pageCache","i","offset","component","createElement","key","withSWR","push"],"mappings":"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","sourcesContent":["import React, { useCallback, useMemo, useState, useRef } from 'react';\nimport { cache } from './config';\n/*\nThe idea\n\nA \"Page\" component renders the content of 1 API request, it accepts an offset (in this example it's from),\nuses a SWR hook (useSWR(API + '?limit=' + limit + '&from=' + from)) and returns items (Projects).\n\nThe UI:\n      +------------------------------------------+\n      |   Projects                               |\n+------------------------------------------------------+\n|     |   +----------------+                     |     |\n|     |                                          |     |\n|     |   +------------+                         |     |\n|     |                                          |     +--> 1 Page\n|     |   +-----------------+                    |     |\n|     |                                          |     |  /projects/list?limit=4\n|     |   +---------+                            |     |\n+------------------------------------------------------+\n      |                                          |\n      |   +------------+                         |     +  /projects/list?limit=4&from=123\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |   +---------+                            |     |\n      |                                          |     |\n      |   +--------------+                       |     +\n      |                                          |\n      |   +-------------------+                  |     +  /projects/list?limit=4&from=456\n      |                                          |     |\n      |   +------------+                         |     |\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |                                          |     +\n\nThe API\n// (inside `render`)\n\nfunction App () {\n  const {\n    pages,    // an array of each page component\n    pageSWRs, // an array of SWRs of each page\n    isLoadingMore,\n    isReachingEnd,\n    isEmpty,\n    loadMore\n  } = useSWRPages(\n    'project-page', // key of this page\n\n    // ======== the actual Page component!\n    ({ offset, withSWR }) => {\n      // required: use `withSWR` to wrap your main SWR (source of your pagination API)\n      const { data } = withSWR(\n        useSWR(API + '?limit=10&from=' + offset) // request projects with offset\n      )\n      if (!data) return <Placeholder>\n      return data.projects.map(project => <Card project={project} team={team}>)\n    },\n    // ========\n\n    // a function accepts a SWR's `data`, and returns the offset of the next page (or null)\n    data => data && data.length >= 10 ? data[data.length - 1].createdAt : null,\n\n    // (optional) outside deps of your Page component. in this case it's empty\n    []\n  )\n\n  // ...\n\n  if (isEmpty) return <EmptyProjectsPage/>\n\n  return <div>\n    {pages}\n    {isReachingEnd\n      ? null\n      : <button loading={isLoadingMore} onClick={loadMore}>Load More</button>}\n  </div>\n}\n*/\nconst pageCacheMap = new Map();\nexport function useSWRPages(pageKey, pageFn, SWRToOffset, deps = []) {\n    const pageCountKey = `_swr_page_count_` + pageKey;\n    const pageOffsetKey = `_swr_page_offset_` + pageKey;\n    const [pageCount, setPageCount] = useState(cache.get(pageCountKey) || 1);\n    const [pageOffsets, setPageOffsets] = useState(cache.get(pageOffsetKey) || [null]);\n    const [pageSWRs, setPageSWRs] = useState([]);\n    const pageFnRef = useRef(pageFn);\n    const emptyPageRef = useRef(false);\n    // Page component (wraps `pageFn`)\n    // for performance reason we need to memorize it\n    const Page = useCallback(props => {\n        // render the page component\n        const dataList = pageFnRef.current(props);\n        // if dataList is [], we can assume this page is empty\n        // TODO: this API is not stable\n        if (dataList && !dataList.length) {\n            emptyPageRef.current = true;\n        }\n        else {\n            emptyPageRef.current = false;\n        }\n        return dataList;\n    }, []);\n    // Doesn't have a next page\n    const isReachingEnd = pageOffsets[pageCount] === null;\n    const isLoadingMore = pageCount === pageOffsets.length;\n    const isEmpty = isReachingEnd && pageCount === 1 && emptyPageRef.current;\n    const loadMore = useCallback(() => {\n        if (isLoadingMore || isReachingEnd)\n            return;\n        setPageCount(c => {\n            cache.set(pageCountKey, c + 1);\n            return c + 1;\n        });\n    }, [isLoadingMore || isReachingEnd]);\n    const _pageFn = useCallback(pageFn, deps);\n    pageFnRef.current = _pageFn;\n    const pages = useMemo(() => {\n        const getWithSWR = id => swr => {\n            if (!pageSWRs[id] ||\n                pageSWRs[id].data !== swr.data ||\n                pageSWRs[id].error !== swr.error ||\n                pageSWRs[id].revalidate !== swr.revalidate) {\n                // hoist side effects: setPageSWRs and setPageOffsets -- https://reactjs.org/blog/2020/02/26/react-v16.13.0.html#warnings-for-some-updates-during-render\n                setTimeout(() => {\n                    setPageSWRs(swrs => {\n                        const _swrs = [...swrs];\n                        _swrs[id] = {\n                            data: swr.data,\n                            error: swr.error,\n                            revalidate: swr.revalidate,\n                            isValidating: swr.isValidating,\n                            mutate: swr.mutate\n                        };\n                        return _swrs;\n                    });\n                    if (typeof swr.data !== 'undefined') {\n                        // set next page's offset\n                        const newPageOffset = SWRToOffset(swr, id);\n                        if (pageOffsets[id + 1] !== newPageOffset) {\n                            setPageOffsets(arr => {\n                                const _arr = [...arr];\n                                _arr[id + 1] = newPageOffset;\n                                cache.set(pageOffsetKey, _arr);\n                                return _arr;\n                            });\n                        }\n                    }\n                });\n            }\n            return swr;\n        };\n        // render each page\n        const p = [];\n        if (!pageCacheMap.has(pageKey)) {\n            pageCacheMap.set(pageKey, []);\n        }\n        const pageCache = pageCacheMap.get(pageKey);\n        for (let i = 0; i < pageCount; ++i) {\n            if (!pageCache[i] ||\n                pageCache[i].offset !== pageOffsets[i] ||\n                pageCache[i].pageFn !== _pageFn) {\n                // when props change or at init\n                // render the page and cache it\n                pageCache[i] = {\n                    component: (React.createElement(Page, { key: `page-${pageOffsets[i]}-${i}`, offset: pageOffsets[i], withSWR: getWithSWR(i) })),\n                    pageFn: _pageFn,\n                    offset: pageOffsets[i]\n                };\n            }\n            p.push(pageCache[i].component);\n        }\n        return p;\n    }, [_pageFn, pageCount, pageSWRs, pageOffsets, pageKey]);\n    return {\n        pages,\n        pageCount,\n        pageSWRs,\n        isLoadingMore,\n        isReachingEnd,\n        isEmpty,\n        loadMore\n    };\n}\n"]},"metadata":{},"sourceType":"module"}