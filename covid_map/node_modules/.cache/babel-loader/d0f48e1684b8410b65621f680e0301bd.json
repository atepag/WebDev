{"ast":null,"code":"\"use strict\"; // The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst _ = require(\"lodash\");\n\nconst cloud_functions_1 = require(\"../cloud-functions\");\n/** @hidden */\n\n\nexports.provider = 'google.analytics';\n/** @hidden */\n\nexports.service = 'app-measurement.com';\n/**\n * Registers a function to handle analytics events.\n *\n * @param analyticsEventType Name of the analytics event type to which\n *   this Cloud Function is scoped.\n *\n * @return Analytics event builder interface.\n */\n\nfunction event(analyticsEventType) {\n  return _eventWithOptions(analyticsEventType, {});\n}\n\nexports.event = event;\n/** @hidden */\n\nfunction _eventWithOptions(analyticsEventType, options) {\n  return new AnalyticsEventBuilder(() => {\n    if (!process.env.GCLOUD_PROJECT) {\n      throw new Error('process.env.GCLOUD_PROJECT is not set.');\n    }\n\n    return 'projects/' + process.env.GCLOUD_PROJECT + '/events/' + analyticsEventType;\n  }, options);\n}\n\nexports._eventWithOptions = _eventWithOptions;\n/**\n * The Firebase Analytics event builder interface.\n *\n * Access via [`functions.analytics.event()`](functions.analytics#.event).\n */\n\nclass AnalyticsEventBuilder {\n  /** @hidden */\n  constructor(triggerResource, options) {\n    this.triggerResource = triggerResource;\n    this.options = options;\n  }\n  /**\n   * Event handler that fires every time a Firebase Analytics event occurs.\n   *\n   * @param handler Event handler that fires every time a Firebase Analytics event\n   *   occurs.\n   *\n   * @return A function that you can export and deploy.\n   */\n\n\n  onLog(handler) {\n    const dataConstructor = raw => {\n      return new AnalyticsEvent(raw.data);\n    };\n\n    return cloud_functions_1.makeCloudFunction({\n      handler,\n      provider: exports.provider,\n      eventType: 'event.log',\n      service: exports.service,\n      legacyEventType: `providers/google.firebase.analytics/eventTypes/event.log`,\n      triggerResource: this.triggerResource,\n      dataConstructor,\n      options: this.options\n    });\n  }\n\n}\n\nexports.AnalyticsEventBuilder = AnalyticsEventBuilder;\n/** Interface representing a Firebase Analytics event that was logged for a specific user. */\n\nclass AnalyticsEvent {\n  /** @hidden */\n  constructor(wireFormat) {\n    this.params = {}; // In case of absent field, show empty (not absent) map.\n\n    if (wireFormat.eventDim && wireFormat.eventDim.length > 0) {\n      // If there's an eventDim, there'll always be exactly one.\n      const eventDim = wireFormat.eventDim[0];\n      copyField(eventDim, this, 'name');\n      copyField(eventDim, this, 'params', p => _.mapValues(p, unwrapValue));\n      copyFieldTo(eventDim, this, 'valueInUsd', 'valueInUSD');\n      copyFieldTo(eventDim, this, 'date', 'reportingDate');\n      copyTimestampToString(eventDim, this, 'timestampMicros', 'logTime');\n      copyTimestampToString(eventDim, this, 'previousTimestampMicros', 'previousLogTime');\n    }\n\n    copyFieldTo(wireFormat, this, 'userDim', 'user', dim => new UserDimensions(dim));\n  }\n\n}\n\nexports.AnalyticsEvent = AnalyticsEvent;\n/**\n * Interface representing the user who triggered the events.\n */\n\nclass UserDimensions {\n  /** @hidden */\n  constructor(wireFormat) {\n    // These are interfaces or primitives, no transformation needed.\n    copyFields(wireFormat, this, ['userId', 'deviceInfo', 'geoInfo', 'appInfo']); // The following fields do need transformations of some sort.\n\n    copyTimestampToString(wireFormat, this, 'firstOpenTimestampMicros', 'firstOpenTime');\n    this.userProperties = {}; // With no entries in the wire format, present an empty (as opposed to absent) map.\n\n    copyField(wireFormat, this, 'userProperties', r => _.mapValues(r, p => new UserPropertyValue(p)));\n    copyField(wireFormat, this, 'bundleInfo', r => new ExportBundleInfo(r)); // BUG(36000368) Remove when no longer necessary\n\n    /* tslint:disable:no-string-literal */\n\n    if (!this.userId && this.userProperties['user_id']) {\n      this.userId = this.userProperties['user_id'].value;\n    }\n    /* tslint:enable:no-string-literal */\n\n  }\n\n}\n\nexports.UserDimensions = UserDimensions;\n/** Predefined or custom properties stored on the client side. */\n\nclass UserPropertyValue {\n  /** @hidden */\n  constructor(wireFormat) {\n    copyField(wireFormat, this, 'value', unwrapValueAsString);\n    copyTimestampToString(wireFormat, this, 'setTimestampUsec', 'setTime');\n  }\n\n}\n\nexports.UserPropertyValue = UserPropertyValue;\n/** Interface representing the bundle these events were uploaded to. */\n\nclass ExportBundleInfo {\n  /** @hidden */\n  constructor(wireFormat) {\n    copyField(wireFormat, this, 'bundleSequenceId');\n    copyTimestampToMillis(wireFormat, this, 'serverTimestampOffsetMicros', 'serverTimestampOffset');\n  }\n\n}\n\nexports.ExportBundleInfo = ExportBundleInfo;\n/** @hidden */\n\nfunction copyFieldTo(from, to, fromField, toField, transform = _.identity) {\n  if (from[fromField] !== undefined) {\n    to[toField] = transform(from[fromField]);\n  }\n}\n/** @hidden */\n\n\nfunction copyField(from, to, field, transform = _.identity) {\n  copyFieldTo(from, to, field, field, transform);\n}\n/** @hidden */\n\n\nfunction copyFields(from, to, fields) {\n  for (const field of fields) {\n    copyField(from, to, field);\n  }\n} // The incoming payload will have fields like:\n// {\n//   'myInt': {\n//     'intValue': '123'\n//   },\n//   'myDouble': {\n//     'doubleValue': 1.0\n//   },\n//   'myFloat': {\n//     'floatValue': 1.1\n//   },\n//   'myString': {\n//     'stringValue': 'hi!'\n//   }\n// }\n//\n// The following method will remove these four types of 'xValue' fields, flattening them\n// to just their values, as a string:\n// {\n//   'myInt': '123',\n//   'myDouble': '1.0',\n//   'myFloat': '1.1',\n//   'myString': 'hi!'\n// }\n//\n// Note that while 'intValue' will have a quoted payload, 'doubleValue' and 'floatValue' will not. This\n// is due to the encoding library, which renders int64 values as strings to avoid loss of precision. This\n// method always returns a string, similarly to avoid loss of precision, unlike the less-conservative\n// 'unwrapValue' method just below.\n\n/** @hidden */\n\n\nfunction unwrapValueAsString(wrapped) {\n  const key = _.keys(wrapped)[0];\n\n  return _.toString(wrapped[key]);\n} // Ditto as the method above, but returning the values in the idiomatic JavaScript type (string for strings,\n// number for numbers):\n// {\n//   'myInt': 123,\n//   'myDouble': 1.0,\n//   'myFloat': 1.1,\n//   'myString': 'hi!'\n// }\n//\n// The field names in the incoming xValue fields identify the type a value has, which for JavaScript's\n// purposes can be divided into 'number' versus 'string'. This method will render all the numbers as\n// JavaScript's 'number' type, since we prefer using idiomatic types. Note that this may lead to loss\n// in precision for int64 fields, so use with care.\n\n/** @hidden */\n\n\nconst xValueNumberFields = ['intValue', 'floatValue', 'doubleValue'];\n/** @hidden */\n\nfunction unwrapValue(wrapped) {\n  const key = _.keys(wrapped)[0];\n\n  const value = unwrapValueAsString(wrapped);\n  return _.includes(xValueNumberFields, key) ? _.toNumber(value) : value;\n} // The JSON payload delivers timestamp fields as strings of timestamps denoted in microseconds.\n// The JavaScript convention is to use numbers denoted in milliseconds. This method\n// makes it easy to convert a field of one type into the other.\n\n/** @hidden */\n\n\nfunction copyTimestampToMillis(from, to, fromName, toName) {\n  if (from[fromName] !== undefined) {\n    to[toName] = _.round(from[fromName] / 1000);\n  }\n} // The JSON payload delivers timestamp fields as strings of timestamps denoted in microseconds.\n// In our SDK, we'd like to present timestamp as ISO-format strings. This method makes it easy\n// to convert a field of one type into the other.\n\n/** @hidden */\n\n\nfunction copyTimestampToString(from, to, fromName, toName) {\n  if (from[fromName] !== undefined) {\n    to[toName] = new Date(from[fromName] / 1000).toISOString();\n  }\n}","map":{"version":3,"sources":["/Users/a3506/Documents/WebDev/Map/WebDev/covid_map/node_modules/firebase-functions/lib/providers/analytics.js"],"names":["Object","defineProperty","exports","value","_","require","cloud_functions_1","provider","service","event","analyticsEventType","_eventWithOptions","options","AnalyticsEventBuilder","process","env","GCLOUD_PROJECT","Error","constructor","triggerResource","onLog","handler","dataConstructor","raw","AnalyticsEvent","data","makeCloudFunction","eventType","legacyEventType","wireFormat","params","eventDim","length","copyField","p","mapValues","unwrapValue","copyFieldTo","copyTimestampToString","dim","UserDimensions","copyFields","userProperties","r","UserPropertyValue","ExportBundleInfo","userId","unwrapValueAsString","copyTimestampToMillis","from","to","fromField","toField","transform","identity","undefined","field","fields","wrapped","key","keys","toString","xValueNumberFields","includes","toNumber","fromName","toName","round","Date","toISOString"],"mappings":"AAAA,a,CACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AACA,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,oBAAD,CAAjC;AACA;;;AACAH,OAAO,CAACK,QAAR,GAAmB,kBAAnB;AACA;;AACAL,OAAO,CAACM,OAAR,GAAkB,qBAAlB;AACA;;;;;;;;;AAQA,SAASC,KAAT,CAAeC,kBAAf,EAAmC;AAC/B,SAAOC,iBAAiB,CAACD,kBAAD,EAAqB,EAArB,CAAxB;AACH;;AACDR,OAAO,CAACO,KAAR,GAAgBA,KAAhB;AACA;;AACA,SAASE,iBAAT,CAA2BD,kBAA3B,EAA+CE,OAA/C,EAAwD;AACpD,SAAO,IAAIC,qBAAJ,CAA0B,MAAM;AACnC,QAAI,CAACC,OAAO,CAACC,GAAR,CAAYC,cAAjB,EAAiC;AAC7B,YAAM,IAAIC,KAAJ,CAAU,wCAAV,CAAN;AACH;;AACD,WAAQ,cAAcH,OAAO,CAACC,GAAR,CAAYC,cAA1B,GAA2C,UAA3C,GAAwDN,kBAAhE;AACH,GALM,EAKJE,OALI,CAAP;AAMH;;AACDV,OAAO,CAACS,iBAAR,GAA4BA,iBAA5B;AACA;;;;;;AAKA,MAAME,qBAAN,CAA4B;AACxB;AACAK,EAAAA,WAAW,CAACC,eAAD,EAAkBP,OAAlB,EAA2B;AAClC,SAAKO,eAAL,GAAuBA,eAAvB;AACA,SAAKP,OAAL,GAAeA,OAAf;AACH;AACD;;;;;;;;;;AAQAQ,EAAAA,KAAK,CAACC,OAAD,EAAU;AACX,UAAMC,eAAe,GAAIC,GAAD,IAAS;AAC7B,aAAO,IAAIC,cAAJ,CAAmBD,GAAG,CAACE,IAAvB,CAAP;AACH,KAFD;;AAGA,WAAOnB,iBAAiB,CAACoB,iBAAlB,CAAoC;AACvCL,MAAAA,OADuC;AAEvCd,MAAAA,QAAQ,EAAEL,OAAO,CAACK,QAFqB;AAGvCoB,MAAAA,SAAS,EAAE,WAH4B;AAIvCnB,MAAAA,OAAO,EAAEN,OAAO,CAACM,OAJsB;AAKvCoB,MAAAA,eAAe,EAAG,0DALqB;AAMvCT,MAAAA,eAAe,EAAE,KAAKA,eANiB;AAOvCG,MAAAA,eAPuC;AAQvCV,MAAAA,OAAO,EAAE,KAAKA;AARyB,KAApC,CAAP;AAUH;;AA5BuB;;AA8B5BV,OAAO,CAACW,qBAAR,GAAgCA,qBAAhC;AACA;;AACA,MAAMW,cAAN,CAAqB;AACjB;AACAN,EAAAA,WAAW,CAACW,UAAD,EAAa;AACpB,SAAKC,MAAL,GAAc,EAAd,CADoB,CACF;;AAClB,QAAID,UAAU,CAACE,QAAX,IAAuBF,UAAU,CAACE,QAAX,CAAoBC,MAApB,GAA6B,CAAxD,EAA2D;AACvD;AACA,YAAMD,QAAQ,GAAGF,UAAU,CAACE,QAAX,CAAoB,CAApB,CAAjB;AACAE,MAAAA,SAAS,CAACF,QAAD,EAAW,IAAX,EAAiB,MAAjB,CAAT;AACAE,MAAAA,SAAS,CAACF,QAAD,EAAW,IAAX,EAAiB,QAAjB,EAA4BG,CAAD,IAAO9B,CAAC,CAAC+B,SAAF,CAAYD,CAAZ,EAAeE,WAAf,CAAlC,CAAT;AACAC,MAAAA,WAAW,CAACN,QAAD,EAAW,IAAX,EAAiB,YAAjB,EAA+B,YAA/B,CAAX;AACAM,MAAAA,WAAW,CAACN,QAAD,EAAW,IAAX,EAAiB,MAAjB,EAAyB,eAAzB,CAAX;AACAO,MAAAA,qBAAqB,CAACP,QAAD,EAAW,IAAX,EAAiB,iBAAjB,EAAoC,SAApC,CAArB;AACAO,MAAAA,qBAAqB,CAACP,QAAD,EAAW,IAAX,EAAiB,yBAAjB,EAA4C,iBAA5C,CAArB;AACH;;AACDM,IAAAA,WAAW,CAACR,UAAD,EAAa,IAAb,EAAmB,SAAnB,EAA8B,MAA9B,EAAuCU,GAAD,IAAS,IAAIC,cAAJ,CAAmBD,GAAnB,CAA/C,CAAX;AACH;;AAfgB;;AAiBrBrC,OAAO,CAACsB,cAAR,GAAyBA,cAAzB;AACA;;;;AAGA,MAAMgB,cAAN,CAAqB;AACjB;AACAtB,EAAAA,WAAW,CAACW,UAAD,EAAa;AACpB;AACAY,IAAAA,UAAU,CAACZ,UAAD,EAAa,IAAb,EAAmB,CACzB,QADyB,EAEzB,YAFyB,EAGzB,SAHyB,EAIzB,SAJyB,CAAnB,CAAV,CAFoB,CAQpB;;AACAS,IAAAA,qBAAqB,CAACT,UAAD,EAAa,IAAb,EAAmB,0BAAnB,EAA+C,eAA/C,CAArB;AACA,SAAKa,cAAL,GAAsB,EAAtB,CAVoB,CAUM;;AAC1BT,IAAAA,SAAS,CAACJ,UAAD,EAAa,IAAb,EAAmB,gBAAnB,EAAsCc,CAAD,IAAOvC,CAAC,CAAC+B,SAAF,CAAYQ,CAAZ,EAAgBT,CAAD,IAAO,IAAIU,iBAAJ,CAAsBV,CAAtB,CAAtB,CAA5C,CAAT;AACAD,IAAAA,SAAS,CAACJ,UAAD,EAAa,IAAb,EAAmB,YAAnB,EAAkCc,CAAD,IAAO,IAAIE,gBAAJ,CAAqBF,CAArB,CAAxC,CAAT,CAZoB,CAapB;;AACA;;AACA,QAAI,CAAC,KAAKG,MAAN,IAAgB,KAAKJ,cAAL,CAAoB,SAApB,CAApB,EAAoD;AAChD,WAAKI,MAAL,GAAc,KAAKJ,cAAL,CAAoB,SAApB,EAA+BvC,KAA7C;AACH;AACD;;AACH;;AArBgB;;AAuBrBD,OAAO,CAACsC,cAAR,GAAyBA,cAAzB;AACA;;AACA,MAAMI,iBAAN,CAAwB;AACpB;AACA1B,EAAAA,WAAW,CAACW,UAAD,EAAa;AACpBI,IAAAA,SAAS,CAACJ,UAAD,EAAa,IAAb,EAAmB,OAAnB,EAA4BkB,mBAA5B,CAAT;AACAT,IAAAA,qBAAqB,CAACT,UAAD,EAAa,IAAb,EAAmB,kBAAnB,EAAuC,SAAvC,CAArB;AACH;;AALmB;;AAOxB3B,OAAO,CAAC0C,iBAAR,GAA4BA,iBAA5B;AACA;;AACA,MAAMC,gBAAN,CAAuB;AACnB;AACA3B,EAAAA,WAAW,CAACW,UAAD,EAAa;AACpBI,IAAAA,SAAS,CAACJ,UAAD,EAAa,IAAb,EAAmB,kBAAnB,CAAT;AACAmB,IAAAA,qBAAqB,CAACnB,UAAD,EAAa,IAAb,EAAmB,6BAAnB,EAAkD,uBAAlD,CAArB;AACH;;AALkB;;AAOvB3B,OAAO,CAAC2C,gBAAR,GAA2BA,gBAA3B;AACA;;AACA,SAASR,WAAT,CAAqBY,IAArB,EAA2BC,EAA3B,EAA+BC,SAA/B,EAA0CC,OAA1C,EAAmDC,SAAS,GAAGjD,CAAC,CAACkD,QAAjE,EAA2E;AACvE,MAAIL,IAAI,CAACE,SAAD,CAAJ,KAAoBI,SAAxB,EAAmC;AAC/BL,IAAAA,EAAE,CAACE,OAAD,CAAF,GAAcC,SAAS,CAACJ,IAAI,CAACE,SAAD,CAAL,CAAvB;AACH;AACJ;AACD;;;AACA,SAASlB,SAAT,CAAmBgB,IAAnB,EAAyBC,EAAzB,EAA6BM,KAA7B,EAAoCH,SAAS,GAAGjD,CAAC,CAACkD,QAAlD,EAA4D;AACxDjB,EAAAA,WAAW,CAACY,IAAD,EAAOC,EAAP,EAAWM,KAAX,EAAkBA,KAAlB,EAAyBH,SAAzB,CAAX;AACH;AACD;;;AACA,SAASZ,UAAT,CAAoBQ,IAApB,EAA0BC,EAA1B,EAA8BO,MAA9B,EAAsC;AAClC,OAAK,MAAMD,KAAX,IAAoBC,MAApB,EAA4B;AACxBxB,IAAAA,SAAS,CAACgB,IAAD,EAAOC,EAAP,EAAWM,KAAX,CAAT;AACH;AACJ,C,CACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;AACA,SAAST,mBAAT,CAA6BW,OAA7B,EAAsC;AAClC,QAAMC,GAAG,GAAGvD,CAAC,CAACwD,IAAF,CAAOF,OAAP,EAAgB,CAAhB,CAAZ;;AACA,SAAOtD,CAAC,CAACyD,QAAF,CAAWH,OAAO,CAACC,GAAD,CAAlB,CAAP;AACH,C,CACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;AACA,MAAMG,kBAAkB,GAAG,CAAC,UAAD,EAAa,YAAb,EAA2B,aAA3B,CAA3B;AACA;;AACA,SAAS1B,WAAT,CAAqBsB,OAArB,EAA8B;AAC1B,QAAMC,GAAG,GAAGvD,CAAC,CAACwD,IAAF,CAAOF,OAAP,EAAgB,CAAhB,CAAZ;;AACA,QAAMvD,KAAK,GAAG4C,mBAAmB,CAACW,OAAD,CAAjC;AACA,SAAOtD,CAAC,CAAC2D,QAAF,CAAWD,kBAAX,EAA+BH,GAA/B,IAAsCvD,CAAC,CAAC4D,QAAF,CAAW7D,KAAX,CAAtC,GAA0DA,KAAjE;AACH,C,CACD;AACA;AACA;;AACA;;;AACA,SAAS6C,qBAAT,CAA+BC,IAA/B,EAAqCC,EAArC,EAAyCe,QAAzC,EAAmDC,MAAnD,EAA2D;AACvD,MAAIjB,IAAI,CAACgB,QAAD,CAAJ,KAAmBV,SAAvB,EAAkC;AAC9BL,IAAAA,EAAE,CAACgB,MAAD,CAAF,GAAa9D,CAAC,CAAC+D,KAAF,CAAQlB,IAAI,CAACgB,QAAD,CAAJ,GAAiB,IAAzB,CAAb;AACH;AACJ,C,CACD;AACA;AACA;;AACA;;;AACA,SAAS3B,qBAAT,CAA+BW,IAA/B,EAAqCC,EAArC,EAAyCe,QAAzC,EAAmDC,MAAnD,EAA2D;AACvD,MAAIjB,IAAI,CAACgB,QAAD,CAAJ,KAAmBV,SAAvB,EAAkC;AAC9BL,IAAAA,EAAE,CAACgB,MAAD,CAAF,GAAa,IAAIE,IAAJ,CAASnB,IAAI,CAACgB,QAAD,CAAJ,GAAiB,IAA1B,EAAgCI,WAAhC,EAAb;AACH;AACJ","sourcesContent":["\"use strict\";\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _ = require(\"lodash\");\nconst cloud_functions_1 = require(\"../cloud-functions\");\n/** @hidden */\nexports.provider = 'google.analytics';\n/** @hidden */\nexports.service = 'app-measurement.com';\n/**\n * Registers a function to handle analytics events.\n *\n * @param analyticsEventType Name of the analytics event type to which\n *   this Cloud Function is scoped.\n *\n * @return Analytics event builder interface.\n */\nfunction event(analyticsEventType) {\n    return _eventWithOptions(analyticsEventType, {});\n}\nexports.event = event;\n/** @hidden */\nfunction _eventWithOptions(analyticsEventType, options) {\n    return new AnalyticsEventBuilder(() => {\n        if (!process.env.GCLOUD_PROJECT) {\n            throw new Error('process.env.GCLOUD_PROJECT is not set.');\n        }\n        return ('projects/' + process.env.GCLOUD_PROJECT + '/events/' + analyticsEventType);\n    }, options);\n}\nexports._eventWithOptions = _eventWithOptions;\n/**\n * The Firebase Analytics event builder interface.\n *\n * Access via [`functions.analytics.event()`](functions.analytics#.event).\n */\nclass AnalyticsEventBuilder {\n    /** @hidden */\n    constructor(triggerResource, options) {\n        this.triggerResource = triggerResource;\n        this.options = options;\n    }\n    /**\n     * Event handler that fires every time a Firebase Analytics event occurs.\n     *\n     * @param handler Event handler that fires every time a Firebase Analytics event\n     *   occurs.\n     *\n     * @return A function that you can export and deploy.\n     */\n    onLog(handler) {\n        const dataConstructor = (raw) => {\n            return new AnalyticsEvent(raw.data);\n        };\n        return cloud_functions_1.makeCloudFunction({\n            handler,\n            provider: exports.provider,\n            eventType: 'event.log',\n            service: exports.service,\n            legacyEventType: `providers/google.firebase.analytics/eventTypes/event.log`,\n            triggerResource: this.triggerResource,\n            dataConstructor,\n            options: this.options,\n        });\n    }\n}\nexports.AnalyticsEventBuilder = AnalyticsEventBuilder;\n/** Interface representing a Firebase Analytics event that was logged for a specific user. */\nclass AnalyticsEvent {\n    /** @hidden */\n    constructor(wireFormat) {\n        this.params = {}; // In case of absent field, show empty (not absent) map.\n        if (wireFormat.eventDim && wireFormat.eventDim.length > 0) {\n            // If there's an eventDim, there'll always be exactly one.\n            const eventDim = wireFormat.eventDim[0];\n            copyField(eventDim, this, 'name');\n            copyField(eventDim, this, 'params', (p) => _.mapValues(p, unwrapValue));\n            copyFieldTo(eventDim, this, 'valueInUsd', 'valueInUSD');\n            copyFieldTo(eventDim, this, 'date', 'reportingDate');\n            copyTimestampToString(eventDim, this, 'timestampMicros', 'logTime');\n            copyTimestampToString(eventDim, this, 'previousTimestampMicros', 'previousLogTime');\n        }\n        copyFieldTo(wireFormat, this, 'userDim', 'user', (dim) => new UserDimensions(dim));\n    }\n}\nexports.AnalyticsEvent = AnalyticsEvent;\n/**\n * Interface representing the user who triggered the events.\n */\nclass UserDimensions {\n    /** @hidden */\n    constructor(wireFormat) {\n        // These are interfaces or primitives, no transformation needed.\n        copyFields(wireFormat, this, [\n            'userId',\n            'deviceInfo',\n            'geoInfo',\n            'appInfo',\n        ]);\n        // The following fields do need transformations of some sort.\n        copyTimestampToString(wireFormat, this, 'firstOpenTimestampMicros', 'firstOpenTime');\n        this.userProperties = {}; // With no entries in the wire format, present an empty (as opposed to absent) map.\n        copyField(wireFormat, this, 'userProperties', (r) => _.mapValues(r, (p) => new UserPropertyValue(p)));\n        copyField(wireFormat, this, 'bundleInfo', (r) => new ExportBundleInfo(r));\n        // BUG(36000368) Remove when no longer necessary\n        /* tslint:disable:no-string-literal */\n        if (!this.userId && this.userProperties['user_id']) {\n            this.userId = this.userProperties['user_id'].value;\n        }\n        /* tslint:enable:no-string-literal */\n    }\n}\nexports.UserDimensions = UserDimensions;\n/** Predefined or custom properties stored on the client side. */\nclass UserPropertyValue {\n    /** @hidden */\n    constructor(wireFormat) {\n        copyField(wireFormat, this, 'value', unwrapValueAsString);\n        copyTimestampToString(wireFormat, this, 'setTimestampUsec', 'setTime');\n    }\n}\nexports.UserPropertyValue = UserPropertyValue;\n/** Interface representing the bundle these events were uploaded to. */\nclass ExportBundleInfo {\n    /** @hidden */\n    constructor(wireFormat) {\n        copyField(wireFormat, this, 'bundleSequenceId');\n        copyTimestampToMillis(wireFormat, this, 'serverTimestampOffsetMicros', 'serverTimestampOffset');\n    }\n}\nexports.ExportBundleInfo = ExportBundleInfo;\n/** @hidden */\nfunction copyFieldTo(from, to, fromField, toField, transform = _.identity) {\n    if (from[fromField] !== undefined) {\n        to[toField] = transform(from[fromField]);\n    }\n}\n/** @hidden */\nfunction copyField(from, to, field, transform = _.identity) {\n    copyFieldTo(from, to, field, field, transform);\n}\n/** @hidden */\nfunction copyFields(from, to, fields) {\n    for (const field of fields) {\n        copyField(from, to, field);\n    }\n}\n// The incoming payload will have fields like:\n// {\n//   'myInt': {\n//     'intValue': '123'\n//   },\n//   'myDouble': {\n//     'doubleValue': 1.0\n//   },\n//   'myFloat': {\n//     'floatValue': 1.1\n//   },\n//   'myString': {\n//     'stringValue': 'hi!'\n//   }\n// }\n//\n// The following method will remove these four types of 'xValue' fields, flattening them\n// to just their values, as a string:\n// {\n//   'myInt': '123',\n//   'myDouble': '1.0',\n//   'myFloat': '1.1',\n//   'myString': 'hi!'\n// }\n//\n// Note that while 'intValue' will have a quoted payload, 'doubleValue' and 'floatValue' will not. This\n// is due to the encoding library, which renders int64 values as strings to avoid loss of precision. This\n// method always returns a string, similarly to avoid loss of precision, unlike the less-conservative\n// 'unwrapValue' method just below.\n/** @hidden */\nfunction unwrapValueAsString(wrapped) {\n    const key = _.keys(wrapped)[0];\n    return _.toString(wrapped[key]);\n}\n// Ditto as the method above, but returning the values in the idiomatic JavaScript type (string for strings,\n// number for numbers):\n// {\n//   'myInt': 123,\n//   'myDouble': 1.0,\n//   'myFloat': 1.1,\n//   'myString': 'hi!'\n// }\n//\n// The field names in the incoming xValue fields identify the type a value has, which for JavaScript's\n// purposes can be divided into 'number' versus 'string'. This method will render all the numbers as\n// JavaScript's 'number' type, since we prefer using idiomatic types. Note that this may lead to loss\n// in precision for int64 fields, so use with care.\n/** @hidden */\nconst xValueNumberFields = ['intValue', 'floatValue', 'doubleValue'];\n/** @hidden */\nfunction unwrapValue(wrapped) {\n    const key = _.keys(wrapped)[0];\n    const value = unwrapValueAsString(wrapped);\n    return _.includes(xValueNumberFields, key) ? _.toNumber(value) : value;\n}\n// The JSON payload delivers timestamp fields as strings of timestamps denoted in microseconds.\n// The JavaScript convention is to use numbers denoted in milliseconds. This method\n// makes it easy to convert a field of one type into the other.\n/** @hidden */\nfunction copyTimestampToMillis(from, to, fromName, toName) {\n    if (from[fromName] !== undefined) {\n        to[toName] = _.round(from[fromName] / 1000);\n    }\n}\n// The JSON payload delivers timestamp fields as strings of timestamps denoted in microseconds.\n// In our SDK, we'd like to present timestamp as ISO-format strings. This method makes it easy\n// to convert a field of one type into the other.\n/** @hidden */\nfunction copyTimestampToString(from, to, fromName, toName) {\n    if (from[fromName] !== undefined) {\n        to[toName] = new Date(from[fromName] / 1000).toISOString();\n    }\n}\n"]},"metadata":{},"sourceType":"script"}