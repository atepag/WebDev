{"ast":null,"code":"\"use strict\"; // The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst _ = require(\"lodash\");\n/** @hidden */\n\n\nconst WILDCARD_REGEX = new RegExp('{[^/{}]*}', 'g');\n/**\n * The Functions interface for events that change state, such as\n * Realtime Database or Cloud Firestore `onWrite` and `onUpdate`.\n *\n * For more information about the format used to construct `Change` objects, see\n * [`cloud-functions.ChangeJson`](/docs/reference/functions/cloud_functions_.changejson).\n *\n */\n\nclass Change {\n  constructor(before, after) {\n    this.before = before;\n    this.after = after;\n  }\n\n}\n\nexports.Change = Change;\n\n(function (Change) {\n  /** @hidden */\n  function reinterpretCast(x) {\n    return x;\n  }\n  /**\n   * @hidden\n   * Factory method for creating a Change from a `before` object and an `after`\n   * object.\n   */\n\n\n  function fromObjects(before, after) {\n    return new Change(before, after);\n  }\n\n  Change.fromObjects = fromObjects;\n  /**\n   * @hidden\n   * Factory method for creating a Change from a JSON and an optional customizer\n   * function to be applied to both the `before` and the `after` fields.\n   */\n\n  function fromJSON(json, customizer = reinterpretCast) {\n    let before = _.assign({}, json.before);\n\n    if (json.fieldMask) {\n      before = applyFieldMask(before, json.after, json.fieldMask);\n    }\n\n    return Change.fromObjects(customizer(before || {}), customizer(json.after || {}));\n  }\n\n  Change.fromJSON = fromJSON;\n  /** @hidden */\n\n  function applyFieldMask(sparseBefore, after, fieldMask) {\n    const before = _.assign({}, after);\n\n    const masks = fieldMask.split(',');\n\n    _.forEach(masks, mask => {\n      const val = _.get(sparseBefore, mask);\n\n      if (typeof val === 'undefined') {\n        _.unset(before, mask);\n      } else {\n        _.set(before, mask, val);\n      }\n    });\n\n    return before;\n  }\n\n  Change.applyFieldMask = applyFieldMask;\n})(Change = exports.Change || (exports.Change = {}));\n/** @hidden */\n\n\nfunction makeCloudFunction({\n  after = () => {},\n  before = () => {},\n  contextOnlyHandler,\n  dataConstructor = raw => raw.data,\n  eventType,\n  handler,\n  labels = {},\n  legacyEventType,\n  options = {},\n  provider,\n  service,\n  triggerResource\n}) {\n  const cloudFunction = (data, context) => {\n    if (legacyEventType && context.eventType === legacyEventType) {\n      /*\n       * v1beta1 event flow has different format for context, transform them to\n       * new format.\n       */\n      context.eventType = provider + '.' + eventType;\n      context.resource = {\n        service,\n        name: context.resource\n      };\n    }\n\n    const event = {\n      data,\n      context\n    };\n\n    if (provider === 'google.firebase.database') {\n      context.authType = _detectAuthType(event);\n\n      if (context.authType !== 'ADMIN') {\n        context.auth = _makeAuth(event, context.authType);\n      } else {\n        delete context.auth;\n      }\n    }\n\n    if (triggerResource() == null) {\n      Object.defineProperty(context, 'params', {\n        get: () => {\n          throw new Error('context.params is not available when using the handler namespace.');\n        }\n      });\n    } else {\n      context.params = context.params || _makeParams(context, triggerResource);\n    }\n\n    before(event);\n    let promise;\n\n    if (labels && labels['deployment-scheduled']) {\n      // Scheduled function do not have meaningful data, so exclude it\n      promise = contextOnlyHandler(context);\n    } else {\n      const dataOrChange = dataConstructor(event);\n      promise = handler(dataOrChange, context);\n    }\n\n    if (typeof promise === 'undefined') {\n      console.warn('Function returned undefined, expected Promise or value');\n    }\n\n    return Promise.resolve(promise).then(result => {\n      after(event);\n      return result;\n    }).catch(err => {\n      after(event);\n      return Promise.reject(err);\n    });\n  };\n\n  Object.defineProperty(cloudFunction, '__trigger', {\n    get: () => {\n      if (triggerResource() == null) {\n        return {};\n      }\n\n      const trigger = _.assign(optionsToTrigger(options), {\n        eventTrigger: {\n          resource: triggerResource(),\n          eventType: legacyEventType || provider + '.' + eventType,\n          service\n        }\n      });\n\n      if (!_.isEmpty(labels)) {\n        trigger.labels = labels;\n      }\n\n      return trigger;\n    }\n  });\n  cloudFunction.run = handler || contextOnlyHandler;\n  return cloudFunction;\n}\n\nexports.makeCloudFunction = makeCloudFunction;\n/** @hidden */\n\nfunction _makeParams(context, triggerResourceGetter) {\n  if (context.params) {\n    // In unit testing, user may directly provide `context.params`.\n    return context.params;\n  }\n\n  if (!context.resource) {\n    // In unit testing, `resource` may be unpopulated for a test event.\n    return {};\n  }\n\n  const triggerResource = triggerResourceGetter();\n  const wildcards = triggerResource.match(WILDCARD_REGEX);\n  const params = {};\n\n  if (wildcards) {\n    const triggerResourceParts = _.split(triggerResource, '/');\n\n    const eventResourceParts = _.split(context.resource.name, '/');\n\n    _.forEach(wildcards, wildcard => {\n      const wildcardNoBraces = wildcard.slice(1, -1);\n\n      const position = _.indexOf(triggerResourceParts, wildcard);\n\n      params[wildcardNoBraces] = eventResourceParts[position];\n    });\n  }\n\n  return params;\n}\n/** @hidden */\n\n\nfunction _makeAuth(event, authType) {\n  if (authType === 'UNAUTHENTICATED') {\n    return null;\n  }\n\n  return {\n    uid: _.get(event, 'context.auth.variable.uid'),\n    token: _.get(event, 'context.auth.variable.token')\n  };\n}\n/** @hidden */\n\n\nfunction _detectAuthType(event) {\n  if (_.get(event, 'context.auth.admin')) {\n    return 'ADMIN';\n  }\n\n  if (_.has(event, 'context.auth.variable')) {\n    return 'USER';\n  }\n\n  return 'UNAUTHENTICATED';\n}\n/** @hidden */\n\n\nfunction optionsToTrigger(options) {\n  const trigger = {};\n\n  if (options.regions) {\n    trigger.regions = options.regions;\n  }\n\n  if (options.timeoutSeconds) {\n    trigger.timeout = options.timeoutSeconds.toString() + 's';\n  }\n\n  if (options.memory) {\n    const memoryLookup = {\n      '128MB': 128,\n      '256MB': 256,\n      '512MB': 512,\n      '1GB': 1024,\n      '2GB': 2048\n    };\n    trigger.availableMemoryMb = _.get(memoryLookup, options.memory);\n  }\n\n  if (options.schedule) {\n    trigger.schedule = options.schedule;\n  }\n\n  if (options.maxInstances) {\n    trigger.maxInstances = options.maxInstances;\n  }\n\n  return trigger;\n}\n\nexports.optionsToTrigger = optionsToTrigger;","map":{"version":3,"sources":["/Users/a3506/Documents/WebDev/Map/WebDev/covid_map/node_modules/firebase-functions/lib/cloud-functions.js"],"names":["Object","defineProperty","exports","value","_","require","WILDCARD_REGEX","RegExp","Change","constructor","before","after","reinterpretCast","x","fromObjects","fromJSON","json","customizer","assign","fieldMask","applyFieldMask","sparseBefore","masks","split","forEach","mask","val","get","unset","set","makeCloudFunction","contextOnlyHandler","dataConstructor","raw","data","eventType","handler","labels","legacyEventType","options","provider","service","triggerResource","cloudFunction","context","resource","name","event","authType","_detectAuthType","auth","_makeAuth","Error","params","_makeParams","promise","dataOrChange","console","warn","Promise","resolve","then","result","catch","err","reject","trigger","optionsToTrigger","eventTrigger","isEmpty","run","triggerResourceGetter","wildcards","match","triggerResourceParts","eventResourceParts","wildcard","wildcardNoBraces","slice","position","indexOf","uid","token","has","regions","timeoutSeconds","timeout","toString","memory","memoryLookup","availableMemoryMb","schedule","maxInstances"],"mappings":"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","sourcesContent":["\"use strict\";\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _ = require(\"lodash\");\n/** @hidden */\nconst WILDCARD_REGEX = new RegExp('{[^/{}]*}', 'g');\n/**\n * The Functions interface for events that change state, such as\n * Realtime Database or Cloud Firestore `onWrite` and `onUpdate`.\n *\n * For more information about the format used to construct `Change` objects, see\n * [`cloud-functions.ChangeJson`](/docs/reference/functions/cloud_functions_.changejson).\n *\n */\nclass Change {\n    constructor(before, after) {\n        this.before = before;\n        this.after = after;\n    }\n}\nexports.Change = Change;\n(function (Change) {\n    /** @hidden */\n    function reinterpretCast(x) {\n        return x;\n    }\n    /**\n     * @hidden\n     * Factory method for creating a Change from a `before` object and an `after`\n     * object.\n     */\n    function fromObjects(before, after) {\n        return new Change(before, after);\n    }\n    Change.fromObjects = fromObjects;\n    /**\n     * @hidden\n     * Factory method for creating a Change from a JSON and an optional customizer\n     * function to be applied to both the `before` and the `after` fields.\n     */\n    function fromJSON(json, customizer = reinterpretCast) {\n        let before = _.assign({}, json.before);\n        if (json.fieldMask) {\n            before = applyFieldMask(before, json.after, json.fieldMask);\n        }\n        return Change.fromObjects(customizer(before || {}), customizer(json.after || {}));\n    }\n    Change.fromJSON = fromJSON;\n    /** @hidden */\n    function applyFieldMask(sparseBefore, after, fieldMask) {\n        const before = _.assign({}, after);\n        const masks = fieldMask.split(',');\n        _.forEach(masks, (mask) => {\n            const val = _.get(sparseBefore, mask);\n            if (typeof val === 'undefined') {\n                _.unset(before, mask);\n            }\n            else {\n                _.set(before, mask, val);\n            }\n        });\n        return before;\n    }\n    Change.applyFieldMask = applyFieldMask;\n})(Change = exports.Change || (exports.Change = {}));\n/** @hidden */\nfunction makeCloudFunction({ after = () => { }, before = () => { }, contextOnlyHandler, dataConstructor = (raw) => raw.data, eventType, handler, labels = {}, legacyEventType, options = {}, provider, service, triggerResource, }) {\n    const cloudFunction = (data, context) => {\n        if (legacyEventType && context.eventType === legacyEventType) {\n            /*\n             * v1beta1 event flow has different format for context, transform them to\n             * new format.\n             */\n            context.eventType = provider + '.' + eventType;\n            context.resource = {\n                service,\n                name: context.resource,\n            };\n        }\n        const event = {\n            data,\n            context,\n        };\n        if (provider === 'google.firebase.database') {\n            context.authType = _detectAuthType(event);\n            if (context.authType !== 'ADMIN') {\n                context.auth = _makeAuth(event, context.authType);\n            }\n            else {\n                delete context.auth;\n            }\n        }\n        if (triggerResource() == null) {\n            Object.defineProperty(context, 'params', {\n                get: () => {\n                    throw new Error('context.params is not available when using the handler namespace.');\n                },\n            });\n        }\n        else {\n            context.params = context.params || _makeParams(context, triggerResource);\n        }\n        before(event);\n        let promise;\n        if (labels && labels['deployment-scheduled']) {\n            // Scheduled function do not have meaningful data, so exclude it\n            promise = contextOnlyHandler(context);\n        }\n        else {\n            const dataOrChange = dataConstructor(event);\n            promise = handler(dataOrChange, context);\n        }\n        if (typeof promise === 'undefined') {\n            console.warn('Function returned undefined, expected Promise or value');\n        }\n        return Promise.resolve(promise)\n            .then((result) => {\n            after(event);\n            return result;\n        })\n            .catch((err) => {\n            after(event);\n            return Promise.reject(err);\n        });\n    };\n    Object.defineProperty(cloudFunction, '__trigger', {\n        get: () => {\n            if (triggerResource() == null) {\n                return {};\n            }\n            const trigger = _.assign(optionsToTrigger(options), {\n                eventTrigger: {\n                    resource: triggerResource(),\n                    eventType: legacyEventType || provider + '.' + eventType,\n                    service,\n                },\n            });\n            if (!_.isEmpty(labels)) {\n                trigger.labels = labels;\n            }\n            return trigger;\n        },\n    });\n    cloudFunction.run = handler || contextOnlyHandler;\n    return cloudFunction;\n}\nexports.makeCloudFunction = makeCloudFunction;\n/** @hidden */\nfunction _makeParams(context, triggerResourceGetter) {\n    if (context.params) {\n        // In unit testing, user may directly provide `context.params`.\n        return context.params;\n    }\n    if (!context.resource) {\n        // In unit testing, `resource` may be unpopulated for a test event.\n        return {};\n    }\n    const triggerResource = triggerResourceGetter();\n    const wildcards = triggerResource.match(WILDCARD_REGEX);\n    const params = {};\n    if (wildcards) {\n        const triggerResourceParts = _.split(triggerResource, '/');\n        const eventResourceParts = _.split(context.resource.name, '/');\n        _.forEach(wildcards, (wildcard) => {\n            const wildcardNoBraces = wildcard.slice(1, -1);\n            const position = _.indexOf(triggerResourceParts, wildcard);\n            params[wildcardNoBraces] = eventResourceParts[position];\n        });\n    }\n    return params;\n}\n/** @hidden */\nfunction _makeAuth(event, authType) {\n    if (authType === 'UNAUTHENTICATED') {\n        return null;\n    }\n    return {\n        uid: _.get(event, 'context.auth.variable.uid'),\n        token: _.get(event, 'context.auth.variable.token'),\n    };\n}\n/** @hidden */\nfunction _detectAuthType(event) {\n    if (_.get(event, 'context.auth.admin')) {\n        return 'ADMIN';\n    }\n    if (_.has(event, 'context.auth.variable')) {\n        return 'USER';\n    }\n    return 'UNAUTHENTICATED';\n}\n/** @hidden */\nfunction optionsToTrigger(options) {\n    const trigger = {};\n    if (options.regions) {\n        trigger.regions = options.regions;\n    }\n    if (options.timeoutSeconds) {\n        trigger.timeout = options.timeoutSeconds.toString() + 's';\n    }\n    if (options.memory) {\n        const memoryLookup = {\n            '128MB': 128,\n            '256MB': 256,\n            '512MB': 512,\n            '1GB': 1024,\n            '2GB': 2048,\n        };\n        trigger.availableMemoryMb = _.get(memoryLookup, options.memory);\n    }\n    if (options.schedule) {\n        trigger.schedule = options.schedule;\n    }\n    if (options.maxInstances) {\n        trigger.maxInstances = options.maxInstances;\n    }\n    return trigger;\n}\nexports.optionsToTrigger = optionsToTrigger;\n"]},"metadata":{},"sourceType":"script"}